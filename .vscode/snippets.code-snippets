{
  "Domain index file": {
    "prefix": "nbp-d-index",
    "body": [
      "import { Router } from 'express';",
      "import { routes } from './api';",
      "",
      "const defineRoutes = (expressRouter: Router): void => {",
      "  expressRouter.use('/${1:route}', routes());",
      "};",
      "",
      "export default defineRoutes;"
    ],
    "description": "TypeScript boilerplate domain's index file"
  },
  "Domain API CRUD Routes": {
    "prefix": "nbp-d-api",
    "body": [
      "import express, { Request, Response, NextFunction } from 'express';",
      "import logger from '../../libraries/log/logger';",
      "import { AppError } from '../../libraries/error-handling/AppError';",
      "",
      "import {",
      "  create,",
      "  search,",
      "  getById,",
      "  updateById,",
      "  deleteById,",
      "} from './service';",
      "",
      "import { createSchema, updateSchema, idSchema } from './request';",
      "import { validateRequest } from '../../middlewares/request-validate';",
      "import { logRequest } from '../../middlewares/log';",
      "",
      "const model:string = '${1:Product}';",
      "",
      "// CRUD for entity",
      "const routes = (): express.Router => {",
      "  const router = express.Router();",
      "  logger.info(`Setting up routes for ${model}`);",
      "",
      "  router.get('/', logRequest({}), async (req: Request, res: Response, next: NextFunction) => {",
      "    try {",
      "      const items = await search(req.query);",
      "      res.json(items);",
      "    } catch (error) {",
      "      next(error);",
      "    }",
      "  });",
      "",
      "  router.post(",
      "    '/',",
      "    logRequest({}),",
      "    validateRequest({ schema: createSchema }),",
      "    async (req: Request, res: Response, next: NextFunction) => {",
      "      try {",
      "        const item = await create(req.body);",
      "        res.status(201).json(item);",
      "      } catch (error) {",
      "        next(error);",
      "      }",
      "    }",
      "  );",
      "",
      "  router.get(",
      "    '/:id',",
      "    logRequest({}),",
      "    validateRequest({ schema: idSchema, isParam: true }),",
      "    async (req: Request, res: Response, next: NextFunction) => {",
      "      try {",
      "        const item = await getById(req.params.id);",
      "        if (!item) {",
      "          throw new AppError(`${model} not found`, `${model} not found`, 404);",
      "        }",
      "        res.status(200).json(item);",
      "      } catch (error) {",
      "        next(error);",
      "      }",
      "    }",
      "  );",
      "",
      "  router.put(",
      "    '/:id',",
      "    logRequest({}),",
      "    validateRequest({ schema: idSchema, isParam: true }),",
      "    validateRequest({ schema: updateSchema }),",
      "    async (req: Request, res: Response, next: NextFunction) => {",
      "      try {",
      "        const item = await updateById(req.params.id, req.body);",
      "        if (!item) {",
      "          throw new AppError(`${model} not found`, `${model} not found`, 404);",
      "        }",
      "        res.status(200).json(item);",
      "      } catch (error) {",
      "        next(error);",
      "      }",
      "    }",
      "  );",
      "",
      "  router.delete(",
      "    '/:id',",
      "    logRequest({}),",
      "    validateRequest({ schema: idSchema, isParam: true }),",
      "    async (req: Request, res: Response, next: NextFunction) => {",
      "      try {",
      "        await deleteById(req.params.id);",
      "        res.status(204).json({ message: `${model} is deleted` });",
      "      } catch (error) {",
      "        next(error);",
      "      }",
      "    }",
      "  );",
      "",
      "  return router;",
      "};",
      "",
      "export { routes };"
    ],
    "description": "TypeScript CRUD routes for a model"
  },

  "Domain CRUD Service": {
    "prefix": "nbp-d-service",
    "body": [
      "import logger from '../../libraries/log/logger';",
      "import Model from './schema';",
      "import { AppError } from '../../libraries/error-handling/AppError';",
      "",
      "const model:string = '${1:product}';",
      "",
      "interface IData {",
      "  [key: string]: any;",
      "}",
      "",
      "const create = async (data: IData): Promise<any> => {",
      "  try {",
      "    const item = new Model(data);",
      "    const saved = await item.save();",
      "    logger.info(`create(): ${model} created`, {",
      "      id: saved._id,",
      "    });",
      "    return saved;",
      "  } catch (error: any) {",
      "    logger.error(`create(): Failed to create ${model}`, error);",
      "    throw new AppError(`Failed to create ${model}`, error.message);",
      "  }",
      "};",
      "",
      " interface SearchQuery {",
      "  keyword?: string;",
      "}",
      "",
      "const search = async (query: SearchQuery): Promise<any[]> => {",
      "  try {",
      "    const { keyword } = query ?? {};",
      "    const filter: any = {};",
      "    if (keyword) {",
      "      filter.$or = [",
      "        { name: { $regex: keyword, $options: 'i' } },",
      "        { description: { $regex: keyword, $options: 'i' } },",
      "      ];",
      "    }",
      "    const items = await Model.find(filter);",
      "    logger.info('search(): filter and count', {",
      "      filter,",
      "      count: items.length,",
      "    });",
      "    return items;",
      "  } catch (error: any) {",
      "    logger.error(`search(): Failed to search ${model}`, error);",
      "    throw new AppError(`Failed to search ${model}`, error.message, 400);",
      "  }",
      "};",
      "",
      "const getById = async (id: string): Promise<any> => {",
      "  try {",
      "    const item = await Model.findById(id);",
      "    logger.info(`getById(): ${model} fetched`, { id });",
      "    return item;",
      "  } catch (error: any) {",
      "    logger.error(`getById(): Failed to get ${model}`, error);",
      "    throw new AppError(`Failed to get ${model}`, error.message);",
      "  }",
      "};",
      "",
      "const updateById = async (id: string, data: IData): Promise<any> => {",
      "  try {",
      "    const item = await Model.findByIdAndUpdate(id, data, { new: true });",
      "    logger.info(`updateById(): ${model} updated`, { id });",
      "    return item;",
      "  } catch (error: any) {",
      "    logger.error(`updateById(): Failed to update ${model}`, error);",
      "    throw new AppError(`Failed to update ${model}`, error.message);",
      "  }",
      "};",
      "",
      "const deleteById = async (id: string): Promise<boolean> => {",
      "  try {",
      "    await Model.findByIdAndDelete(id);",
      "    logger.info(`deleteById(): ${model} deleted`, { id });",
      "    return true;",
      "  } catch (error: any) {",
      "    logger.error(`deleteById(): Failed to delete ${model}`, error);",
      "    throw new AppError(`Failed to delete ${model}`, error.message);",
      "  }",
      "};",
      "",
      "export {",
      "  create,",
      "  search,",
      "  getById,",
      "  updateById,",
      "  deleteById,",
      "};"
    ],
    "description": "TypeScript CRUD service for a model"
  },
  "Mongoose Schema": {
    "prefix": "nbp-mongoose-schema",
    "body": [
      "import mongoose, { Schema } from 'mongoose';",
      "import { baseSchema } from '../../libraries/db/base-schema';",
      "",
      "// Define an interface for the Product document",
      "export interface I${Model} extends Document {",
      "  name: string;",
      "}",
      "",
      "const schema = new Schema<I${Model}>({",
      "  name: { type: String, required: true },",
      "  // other properties",
      "});",
      "schema.add(baseSchema);",
      "",
      "// Create and export the model",
      "const ProductModel: Model<I${Model}> = mongoose.model<I${Model}>('I${Model}', productSchema);",
      "",
      "export default ProductModel;"
    ],
    "description": "TypeScript Mongoose schema"
  },
  "Joi Validation Schemas": {
    "prefix": "nbp-joi-schemas",
    "body": [
      "import Joi from 'joi';",
      "import mongoose from 'mongoose';",
      "",
      "const createSchema = Joi.object().keys({",
      "  name: Joi.string().required(),",
      "  // other properties",
      "});",
      "",
      "const updateSchema = Joi.object().keys({",
      "  name: Joi.string(),",
      "  // other properties",
      "});",
      "",
      "const idSchema = Joi.object().keys({",
      "  id: Joi.string()",
      "    .custom((value, helpers) => {",
      "      if (!mongoose.Types.ObjectId.isValid(value)) {",
      "        return helpers.error('any.invalid');",
      "      }",
      "      return value;",
      "    }, 'ObjectId validation')",
      "    .required(),",
      "});",
      "",
      "export { createSchema, updateSchema, idSchema };"
    ],
    "description": "TypeScript Joi validation schemas"
  }
}
